{"expireTime":9007200815366030000,"key":"transformer-remark-markdown-html-d2ce3bd94be45281ab98f625fa0f8198-gatsby-remark-katexgatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h3 id=\"ds-4100-data-collection-integration-and-analysis\"><a href=\"#ds-4100-data-collection-integration-and-analysis\" aria-label=\"ds 4100 data collection integration and analysis permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DS 4100 Data Collection, Integration, and Analysis</h3>\n<p>Today we’re talking about storing data in a relational database (MySQL). We’re going to be focusing on SQL right now, in a couple of weeks we’re going to be doing work in NoSQL; MongoDB, couch, etc. Eventually, I’ll have to make a full pipeline of data, starting with collection, then storage, then retrieval, and finally a predictive model. Finally, there needs to be a report; possibly a visualization.</p>\n<p>I think what I would want to do is a website where you give a subreddit, a post, and what you want to comment, and the website predicts how many upvotes it could get. What I’m thinking is:</p>\n<ol>\n<li>Constantly running scraper adding data to a database</li>\n<li>Backend either creates another scraper or retrieves data given a subreddit</li>\n<li>Create a generalized model for upvotes</li>\n<li>Apply the model given a comment </li>\n<li>Return the information</li>\n</ol>\n<p>Back to relational database</p>\n<h3 id=\"relational-data-storage\"><a href=\"#relational-data-storage\" aria-label=\"relational data storage permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Relational Data Storage</h3>\n<ul>\n<li>Tables in a database are stored as tables</li>\n<li>DBMS are tasked with performance, backup, recovery, storage, access, etc.</li>\n<li>Relational databases store data in a relational (tabular) way.</li>\n<li>You get a table back from a database call.</li>\n</ul>\n<p>If the majority of the computation happens on the client side, it’s called a “Fat Client”. The opposite is where a server does most of the work, called a “Fat Server”. The benefit of a fat server is sharing logic across clients. It’s bad to use just file access as a means of a database, because file access only allows one user at a time. Also, a DBMS keeps all the data, and querying in one place, keeping your client lean. The relational data model is the most commonly used model.</p>\n<p>Database types:</p>\n<p>OLTP (On-line transcation processing):</p>\n<ul>\n<li>Support customer service</li>\n<li>Interactive queries and real time updates</li>\n<li>Concurrent access by many users</li>\n</ul>\n<p>OLAP (On-line analytical processing):</p>\n<ul>\n<li>facilitate decision support</li>\n<li>Analytical queries, no real-time update</li>\n<li>Precompute, and redundantly store data to speed up queries</li>\n</ul>\n<p>Data warehouses:</p>\n<ul>\n<li>an OLAP database</li>\n<li>an integrated and consolidated collection of data from multiple sources</li>\n<li>Primarily queried and is non-volatile</li>\n<li>contains data records for a long time</li>\n</ul>\n<p>Process:</p>\n<p>Source database -> extract data -> transform data by running scripts -> store in data warehouse</p>\n<p>The transformation is the ETL layer (extraction, transformation, loading)</p>\n<p>Data marts are the result of the extraction of a subset of data from a data warehouse</p>\n<p>Queries that you would run against a data warehouse are more complex, and require data crunching and models</p>\n<p>Fundamental structure:</p>\n<ul>\n<li>\n<p>Tables are the fundamental structural entity in a relational database</p>\n</li>\n<li>\n<p>Each table represents an entity from the business domain and consists of:</p>\n<ul>\n<li>columns</li>\n<li>rows</li>\n<li>key column</li>\n</ul>\n</li>\n</ul>\n<p>Foreign keys are used to establish links between two different tables.</p>\n<p>Table rules:</p>\n<ul>\n<li>All rows are formatted identically</li>\n<li>Rows are unsorted unless SPECIFICALLY TOLD TO BE SORTED</li>\n<li>Columns are unsorted</li>\n<li>Each row in a table is a unique entity</li>\n<li>There are no duplicate column names</li>\n<li>Within the table, values represnet data</li>\n<li>Each column value is atomic (in a single column, you store a single value)</li>\n</ul>\n<p>Now onto basic SQL queries, which I’m not going to write down. </p>\n<p>We’re going to be using SQLite because it’s easy, small, and available. Other than that, my teacher specified, DONT USE IT :P</p>"}